
# 📘 1주차 - 파이썬 기초 (2번째 수업)

---

## 🧱 객체지향 언어

## 객체(Object)
객체는 자체의 속성과 행동을 함께 가지는 독립적인 단위로, 현실 세계의 사물이나 개념을 소프트웨어적으로 모델링한 것이다.

간단하게 설명하자면 **자체적인 변수와 함수를 갖는 새로운 속성의 코드**정도로 이해해도 좋다.
## 등장배경
소프트웨어가 점점 더 복잡해지고 크기가 커지면서 기존 절차지향언어로는 코드 관리와 유지보수가 어려워졌다. 개발자들은 코드 재사용 및 모듈화를 통해 빠르고 정확한 개발을 원했다. 

객체지향언어는 프로그램을 하나의 **'흐름'** 이란 개념이 아닌 다수의 **'객체'** 로 구성한다. 이는 현실 세계의 다양한 시스템과 유사하다. 

예를 들어, 건물의 위치와 기능, 관계도 등의 정보를 저장하여 지도로 시각화하는 프로그램을 개발한다고 가정하자. 만약 절차지향언어를 사용해서 하나의 흐름으로 프로그램을 개발한다면 코드가 너무 복잡해지고 새로운 건물이 생겨나는 등 프로그램을 수정할 때 매우 어려울 것이다.

객체지향언어라면 각 건물을 하나의 객체로 구현하고 다수의 객체를 동시에 원하는 만큼 사용하는 것으로 이를 구현할 수 있을 것이다. 만약 다른 지역의 동일한 프로그램을 사용하는 경우에도 해당 프로그램을 조금만 수정해서 구현할 수 있을 것이다.

---

## 🏗️ 클래스(Class)

파이썬에서 클래스는 객체를 만들기 위한 설계도로 생각할 수 있다. C를 배운 학생이라면 **함수가 포함될 수 있는 구조체**정도로 생각해도 좋다. 파이썬에서는 정수, 실수, 리스트 등 모든 자료형이 객체고 클래스로 구현된다. 

```python
class A:
    B = 1
    def C(self):
        print('C')
```

이렇게 `class` 키워드와 블록 구조로 클래스를 선언할 수 있다. Colab에서 코드를 작성하라.

```python
test = A()
print(test.B)  # 클래스 내부 변수 접근
test.C()       # 클래스 내부 메소드 호출
```

---
클래스를 사용하는 방식은 함수와 유사하다 `()`를 사용해 선언할 수 있다. 이때 클래스가 저장되는 `test`를 **인스턴스**라고 부른다.

클래스 내부의 변수와 함수를 사용하기 위해서는 `.`을 사용하여 접근할 수 있다. 그냥 `B`를 출력하면 오류가 발생한다. **클래스 내부의 변수는 오직 클래스 내부에서만 사용이 가능하다.**
### self
클래스 내부에서 만들어지는 함수를 **메소드**라고 한다. 이 메소드는 반드시 `self` 매개변수를 포함하여 작성되어야 하고, `self` 매개변수의 위치는 반드시 **첫번째**에 와야 한다.

`self` 매개변수는 메소드가 **자기 자신이 속한 클래스에 접근하기 위해 사용된다.** 해당 메소드 자체를 사용하기 위해선 기본적으로 클래스에 접근해야 하므로 `self` 매개변수는 반드시 작성되어야 한다.

```python
class A:
    B = 1

    def C(self):
        print(self.B)

    def D(self):
        self.B += 1

test = A()
test.C()
test.D()
test.C()
```

해당 코드를 실행해보자. 메소드 `C`,`D`는 각각 `B`를 사용하기 위해 `self.B` 구문을 사용했다. 이렇게 내부의 변수나 메소드를 사용하기 위해 `self`를 사용한다.

---

## 매직 메소드
파이썬에서는 클래스를 만들고 인스턴스를 선언하고 메소드를 호출하여 기능을 수행한다. **매직 메소드**란 **코드로 직접 호출하지 않고 특별한 상황에서 자동으로 호출되는 메소드를 말한다.**
### 생성자
생성자는 인스턴스를 선언할 때 자동으로 호출되는 메소드다. `__init__()` 이란 이름으로 메소드를 작성하면 이 메소드는 인스턴스 선언 시 자동으로 사용된다.

```python
class A:
    def __init__(self):
        print('인스턴스 생성됨')

test = A()
```

생성자에 **매개변수를 추가해서 인스턴스 선언 시 인자를 받게 구현할 수도 있다.**

```python
class A:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def B(self):
        print(self.a, self.b)

test = A(1, 2)
test.B()
```

생성자는 인스턴스 선언 시 값을 원하는 대로 셋팅하고 인스턴스마다 생성 시 새로운 값을 인자로 받을 수 있기 때문에 매우 자주 사용되는 매직 메소드다.

생성자말고도 매우 다양한 매직 메소드가 있다.
- `__del__(self)`
- `__str__(self)`
- `__len__(self)`
- `__getitem__(self)`
## 상속
개발자가 어떤 클래스 A를 만들었다고 가정하자. 추가로 클래스 B를 만들고자 할 때 **클래스 B가 A에서 사용한 메소드 및 변수를 동일하게 사용하고자 한다면 '상속'으로 쉽게 구현할 수 있다.** 

상속이란 클래스를 만들 때 계층적인 구조로 구현할 수 있게 해주는 문법이다.

```python
class person:
    def __init__(self, a, b):
        self.age = a
        self.country = b

    def old(self):
        self.age += 1

class programmer(person):
    def __init__(self, a, b):
        super().__init__(a, b)

    def prin(self):
        super().old()
        print(self.age, self.country)

test = programmer(26, "korea")
test.old()
test.prin()
```

위 코드에서 `old(self)` 메소드를 하위 클래스에서 수정하여 사용했다. 이렇게 상속 해주는 클래스를 **부모 클래스**라고 하고 상속 받는 클래스를 **자식 클래스**라고 한다. 

`super()`은 자식 클래스에서 부모 클래스의 메소드를 호출할 수 있도록 해주는 내장 함수다.

**자식 클래스는 다수의 부모클래스를 가질 수도 있다.**
# 패키지와 라이브러리
파이썬에서 클래스와 상속을 활용해 다양한 객체와 기능을 모듈화할 수 있게 되면서, 개발자들 간에 코드의 재사용과 공유가 활발해졌다.

그러나 하나의 파이썬 파일 `.py` 에 모든 클래스와 함수를 작성해야 하는 것은 매우 비효율적이고 안전하지 않다.

용도에 맞게 개발된 함수와 클래스가 작성된 파이썬 파일을 **모듈**이라고 하고, 다수의 모듈로 구성된 폴더 구조를 **패키지**라고 한다. 패키지와 모듈을 모아놓은 것을 **라이브러리**라고 한다.

라이브러리
├── 패키지 (폴더)
│   ├── 서브패키지
│   │   ├── 모듈 (.py 파일)
│   │   └── ...
│   └── 모듈
└── 단일 모듈 

**라이브러리 ⊃ 패키지 ⊃ 모듈 ⊃ 함수/클래스**

파이썬은 `pip`나 `conda` 등 추가 기능으로 원하는 패키지 및 라이브러리를 인터넷에서 다운로드하여 사용할 수 있다. 자세한 내용은 추후에 다시 설명하도록 하자.

다양한 기능을 갖춘 라이브러리 생태계가 있기 때문에 파이썬은 다양한 분야에서 자주 사용된다.
# Numpy
이번 시간에는 Colab 이미 설치된 `numpy` 라이브러리를 사용해서 어떤 기능을 사용할 수 있는지 확인한다. 개인적인 개발환경이 있다면 따로 `numpy`를 설치해야한다. 

`numpy`는 다차원 배열을 효율적으로 처리하고 벡터화 연산, 선형 대수, 난수 생성, 푸리에 변환등 다양한 수학/과학 계산에 주로 사용되는 고성능 수치 계산을 위한 라이브러리다.

개발자는 `import` 구문을 이용해 **코드 밖에 있는 파이썬 파일의 함수와 클래스를 사용할 수 있다.**

```python
import A
```

`numpy`를 불러올 때는 주로 `as` 를 사용하여 `np` 로 줄여 사용한다.

```python
import numpy as np
```

## np.array
`array`는 `numpy`의 가장 기본적인 연산 단위인 배열 클래스다. 

```python
a = np.array([1, 2, 3])
b = np.array([[1, 2], [3, 4]])
print(a)
print(b)
print(a.shape)
print(b.shape)
print(a.dtype)
print(b.dtype)
print(a.ndim)
print(b.ndim)
```

`array` 인스턴스 선언 시 다차원의 리스트를 인자로 사용하여 선언가능하다. 해당 클래스의 기본적인 변수는 `shape`, `dtype`, `ndim` 등이 있다. 
- `shape` : 배열의 크기를 튜플로 저장.
- `dtype` : 배열 요소의 자료형을 저장. `array`의 모든 요소는 같은 자료형으로 통일됨.
- `ndim` : 배열의 차원 수를 저장.

리스트말고도 배열을 원하는대로 생성하는 함수가 존재한다.

```python
np.zeros((2, 3))
np.ones((3, 3))
np.eye(4)
np.arange(0, 10, 2)
np.linspace(0, 1, 5)
```

- `zeros` : 인자로 받은 크기만큼 0 요소로 찬 배열을 생성.
- `ones` : 인자로 받은 크기만큼 1 요소로 찬 배열을 생성.
- `eye` : 인자로 받은 크기만큼 단위 행렬 생성.
- `arange` : 등차 수열의 정수 배열을 생성.
- `linspace` : 등간격으로 나눈 실수 배열 생성.
## 인덱스
`array`에서도 인덱스가 존재한다.

---

### 브로드캐스팅

```python
a = np.array([1, 2, 3])
print(a + 5)
```

---

### 인덱싱 / 슬라이싱

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[0, 1])     # 2
print(arr[:, 1])     # 두 번째 열
print(arr[arr > 3])  # 4, 5, 6
```

---

### 통계 함수

```python
data = np.array([1, 2, 3, 4, 5])
print(np.mean(data))
print(np.std(data))
print(np.max(data))
```

---

### 배열 변형

```python
a = np.array([[1, 2, 3], [4, 5, 6]])
print(a.reshape(3, 2))
print(a.flatten())
```

---

### 난수 생성

```python
np.random.seed(0)
print(np.random.rand(3, 3))
print(np.random.randn(3, 3))
```

---

### 선형대수 연산

```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[2, 0], [1, 2]])
print(np.dot(a, b))
print(a @ b)
print(a.T)
```

---

## 📝 실습 과제

### 과제 1️⃣: 통계 계산

```python
data = input("숫자 여러 개 입력 (예: 1 2 3): ")
nums = np.array([int(i) for i in data.split()])
print("최댓값:", np.max(nums))
print("최솟값:", np.min(nums))
print("평균:", np.mean(nums))
print("표준편차:", np.std(nums))
```

---

### 과제 2️⃣: 각 요소에 5 더하기

```python
plus5 = nums + 5
print("각 요소에 5를 더한 결과:", plus5)
```
